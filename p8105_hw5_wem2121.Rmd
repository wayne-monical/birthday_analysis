---
title: "HW 5"
author: "Wayne Monical"
date: "2024-11-13"
output: github_document
---

```{r}
library(tidyverse)
set.seed(123)

```

## Problem 1

In this problem, we create a function to simulate whether a group of a given size has at least one shared birthday, assuming birthdays are evenly spread among the 365 days of the year. We simulate this random drawing 10000 for each group size between 2 and 50. Plotting the results of the simulation, we see that the proportion of simulations with at least one shared birthday rises smoothly from close to zero to close to one with increasing group size. 

Creating the birthday function. 
```{r}
n_test = 25

birthday = function(n = 25){
  birthdays = sample(x = 1:365, 
                     size = n,
                     replace = TRUE)
  return(length(unique(birthdays)) < n)
}

birthday(1)

birthday(366)
```

Running the simulation 10000 for each size between 2 and 50
```{r}
group_size = 2:50
n_sim = 10000

sims = 
    matrix(
      0,
      nrow = max(group_size) - min(group_size) + 1,
      ncol = n_sim,
      dimnames = list(group_size, NULL))

# sims = tibble::rowid_to_column(sims, "group_size")

```

Conducting the simulation
```{r}
for(i in group_size){
  for(j in 1:n_sim){
    sims[as.character(i),j] = as.integer(birthday(n = i))
  }
}
```

Taking the average proportion of groups with at least one shared birthday for each group size. 
```{r}
sim_results = data.frame(
  group_size = group_size,
  prop_shared_bday = rowMeans(sims)
)
```

Plotting the results
```{r}
ggplot(
  sim_results, 
  aes(x = group_size, y = prop_shared_bday))+
  geom_point()

```







## Problem 2

Simulating a normal distribution 5000 times. 
```{r}
n_2 = 30
sd_2 = 5
mu_2 = 0

sim_size = 5000
```



Conducting simulation
```{r}
n_2 = 30
sd_2 = 5
mu_2 = 0

sim_size = 5000

sim2a = 
  tibble(
    id = 1:sim_size,
    mu = mu_2
    ) |> 
  mutate(
    sim = map(mu, \(x) rnorm(n = n_2, mean = x, sd = sd_2))
  )
```

Saving the sample average and applying a t-test.
```{r}
sim2a = 
  sim2a |> 
  mutate(
    test = map(
      sim,
      \(x) broom::tidy(
        t.test(
          x = x,
          alternative = 'two.sided',
          mu = 0,
          conf.leve = 0.95
        )))) |> 
  unnest(test)
```

Repeating for mu equal to 1 through 5.
```{r}
mu = data.frame(mu = 0:5)
sim_id = data.frame(id = 1:sim_size)

sim2b = 
  crossing(mu, sim_id) |> 
  mutate(
    sim = map(mu, \(x) rnorm(n = n_2, mean = x, sd = sd_2)),
    test = map(
      sim,
      \(x) broom::tidy(
        t.test(
          x = x,
          alternative = 'two.sided',
          mu = 0,
          conf.level = 0.95
        )))
  ) |> 
  unnest(test) |> 
  mutate(reject_null = p.value < 0.05)
```

Plotting the power of the test.

```{r}
sim2b |> 
  group_by(mu) |> 
  summarize(
    proportion_reject_null = mean(reject_null, na.rm = TRUE)
    ) |> 
  ggplot(aes(x = as.character(mu), y = proportion_reject_null)) +
  geom_point()
```



```{r}
null_reject_ests = 
  sim2b |> 
  filter(reject_null) |> 
  group_by(mu) |> 
  summarize(mu_hat = mean(estimate))


sim2b |> 
  group_by(mu) |> 
  summarize(mu_hat = mean(estimate)) |> 
  ggplot(aes(x = as.character(mu), y = mu_hat)) +
  geom_point() +
  geom_point(data = null_reject_ests, aes(color = 'red'))
```

```{r}
sim2b |> 
  group_by(mu) |> 
  summarize(
    proportion_reject_null = mean(reject_null, na.rm = TRUE)
    ) |> 
  ggplot(aes(x = as.character(mu), y = mu_hat_rejected_null)) +
  geom_point()
```


```{r}
sim2b |> filter(p.value < 0.05)
```


## Problem 3

This data set contains 52,179 victims of homicide across 50 US cities. There is data on the victims' names, ages, races, and sexes. There is a latitude and longitude given for each homicide and a variable titled `disposition` indicating the result of the homicide's investigation. 

read in homicide data
```{r}
homicide = read_csv('homicide-data.csv')
```


Creating a `city_state` variable. 
```{r}
homicide = 
  homicide |> 
  mutate(city_state = paste0(city, ", ", state)) |> 
  mutate(
    unsolved = disposition %in% c(
      'Closed without arrest',
      'Open/No arrest'))
```

```{r}
homicide |> 
  group_by(city_state) |> 
  summarize(
    total = n(),
    unsolved = sum(unsolved)
    ) |> 
  knitr::kable()
 
```



Testing baltimore
```{r}
baltimore = 
  homicide |> 
  filter(city_state == 'Baltimore, MD')

baltimore_unsolved = 
  baltimore |> 
  pull(unsolved) |> 
  sum() |> 
  prop.test(n = nrow(baltimore))  
  

# printing 
baltimore_unsolved |> 
  broom::tidy() |> 
  select(estimate, conf.low, conf.high)
```
Running prop.test for each city
```{r}
unsolved_props=
  homicide |> 
  nest(data = -city_state) |> 
  mutate(prop_test = map(data, 
                        \(x) x |> 
                          pull(unsolved)|> 
                          sum() |> 
                          prop.test(n = nrow(x))),
         test_results = map(prop_test, \(x) broom::tidy(x)),
         ) |> 
  unnest(cols = test_results) |> 
  select(
    city_state, estimate, conf.low, conf.high
  ) |> 
  
```
```{r}
unsolved_props |> 
  ggplot(aes(
    x = reorder(city_state, estimate),
    y = estimate))  +  
  geom_point() + 
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high))+
  theme(axis.text.x = element_text(angle = 90))+
  
```

